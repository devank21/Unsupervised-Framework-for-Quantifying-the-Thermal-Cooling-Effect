# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_nOoOV8InvdAU2jlkKZf8MvyPPx51DrJ
"""



# ===========================================
# üå≥ Tree Cooling Effect Predictor (Colab Edition)
# Author: Devank Gupta
# Purpose: Research prototype for predicting
#          cooling effects of street trees from a photo
# ===========================================

# STEP 1: INSTALL DEPENDENCIES
!pip install opencv-python-headless numpy matplotlib scikit-image pandas tqdm requests --quiet

# (Optional) Uncomment if you have a GPU and want to use Detectron2
# Note: only needed if you later train / use Mask R-CNN for trees
# !pip install 'git+https://github.com/facebookresearch/detectron2.git' --quiet

# ===========================================
# STEP 2: IMPORTS
# ===========================================
import os, math, requests
import numpy as np
import pandas as pd
import cv2
from skimage import segmentation, color, morphology, measure
import matplotlib.pyplot as plt
from tqdm import tqdm

# ===========================================
# STEP 3: UTILITIES
# ===========================================
def load_image(path_or_url: str):
    if path_or_url.startswith("http"):
        r = requests.get(path_or_url, stream=True)
        r.raise_for_status()
        img = np.asarray(bytearray(r.content), dtype=np.uint8)
        img = cv2.imdecode(img, cv2.IMREAD_COLOR)
    else:
        img = cv2.imread(path_or_url)
    if img is None:
        raise ValueError("Could not load image.")
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return img

def compute_vari(img_rgb):
    img = img_rgb.astype(np.float32)
    R, G, B = img[:,:,0], img[:,:,1], img[:,:,2]
    return np.clip((G - R) / ((G + R - B) + 1e-6), -1, 2)

# ===========================================
# STEP 4: UNSUPERVISED TREE MASK GENERATION
# ===========================================
def extract_tree_masks(img_rgb, n_segments=800, vari_thresh=0.1, min_area_px=400):
    img_float = img_rgb.astype(np.float32) / 255.0
    segs = segmentation.slic(img_float, n_segments=n_segments, compactness=10, start_label=1)
    vari_map = compute_vari(img_rgb)
    masks = []
    for sid in np.unique(segs):
        mask = segs == sid
        mean_vari = vari_map[mask].mean()
        if mean_vari > vari_thresh and mask.sum() > min_area_px:
            mask = morphology.remove_small_holes(mask, area_threshold=150)
            masks.append(mask)
    # split connected regions
    refined = []
    for m in masks:
        labeled = measure.label(m)
        for lab in np.unique(labeled):
            if lab == 0: continue
            comp = labeled == lab
            if comp.sum() > min_area_px:
                refined.append(comp)
    return refined, vari_map

# ===========================================
# STEP 5: THERMAL MAP MODEL
# ===========================================
def build_virtual_thermal_map(img_rgb, masks, vari_map, T_base=40, C_max=8):
    h, w, _ = img_rgb.shape
    total_area = h * w
    temp_map = np.full((h,w), T_base, np.float32)
    stats = []
    for i, m in enumerate(masks, 1):
        area = m.sum()
        mean_vari = float(vari_map[m].mean())
        norm_var = np.clip((mean_vari - 0.0) / 0.6, 0, 1)
        area_factor = (area / total_area) ** 0.5
        deltaT = C_max * area_factor * norm_var
        temp_map[m] = np.minimum(temp_map[m], T_base - deltaT)
        props = measure.regionprops(m.astype(np.uint8))[0]
        stats.append({
            "id": i,
            "area_px": area,
            "mean_vari": mean_vari,
            "est_cooling_C": -deltaT,
            "bbox": props.bbox
        })
    return temp_map, pd.DataFrame(stats)

# ===========================================
# STEP 6: VISUALIZATION
# ===========================================
def visualize_results(img_rgb, masks, vari_map, temp_map, stats):
    # Mask overlay
    overlay = img_rgb.copy().astype(np.float32) / 255.0
    cmap = plt.get_cmap("tab20")
    for i, m in enumerate(masks):
        overlay[m] = cmap(i % 20)[:3]
    plt.figure(figsize=(8,6))
    plt.imshow(overlay)
    plt.title("Detected Tree Masks")
    plt.axis('off')
    plt.show()

    # VARI map
    plt.figure(figsize=(8,6))
    plt.imshow(vari_map, cmap='Greens')
    plt.title("Greenness (VARI Index)")
    plt.colorbar(label="VARI")
    plt.axis('off')
    plt.show()

    # Thermal map
    plt.figure(figsize=(8,6))
    plt.imshow(temp_map, cmap='inferno')
    plt.title("Virtual Thermal Map (¬∞C)")
    plt.colorbar(label="Predicted Temperature")
    plt.axis('off')
    plt.show()

    # Annotated results
    annotated = img_rgb.copy()
    for _, row in stats.iterrows():
        (minr, minc, maxr, maxc) = row["bbox"]
        cv2.rectangle(annotated, (minc, minr), (maxc, maxr), (0,255,0), 2)
        text = f"ID{int(row['id'])}: ŒîT={row['est_cooling_C']:.2f}¬∞C"
        cv2.putText(annotated, text, (minc, maxr+15),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.45, (255,0,0), 1)
    plt.figure(figsize=(10,7))
    plt.imshow(annotated)
    plt.title("Annotated Trees with Cooling Estimates")
    plt.axis('off')
    plt.show()
    display(stats)

# ===========================================
# STEP 7: RUN PIPELINE
# ===========================================
# üåê Provide an image URL or upload manually
# Example: image_url = "https://landcarbonlab.org/data/global-tree-canopy-height/" (replace with direct JPG)
# or upload using the file uploader below üëá

from google.colab import files

print("‚¨ÜÔ∏è Upload a street image (JPG/PNG)...")
uploaded = files.upload()
img_path = list(uploaded.keys())[0]
img_rgb = load_image(img_path)

# Run analysis
masks, vari_map = extract_tree_masks(img_rgb)
temp_map, stats = build_virtual_thermal_map(img_rgb, masks, vari_map)

# Visualize results
visualize_results(img_rgb, masks, vari_map, temp_map, stats)